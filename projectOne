#include <iostream>
#include <fstream>
#include <thread>
#include <mutex>
#include <atomic>
#include <vector>
#include <string>

// Functions
// checks if character is in the alphabet 
bool isAlpha(char c) {
    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}

//converts character to lowercase
char toLower(char c) {
    if (c >= 'A' && c <= 'Z') {
        return c - ('A' - 'a');
    }
    return c;
}


void processChunk(const std::string& textChunk) {
    std::string word;
    for (char c : textChunk) {
        if (isAlpha(c)) {
            word += toLower(c);
        } else if (!word.empty()) {
            countWord(word);
            word.clear();
        }
    }
    if (!word.empty()) {
        countWord(word);
    }
}




// Global variables
std::unordered_map<std::string, int> wordCount;
std::mutex wordCountMutex;

int main(int argc, char** argv) {
    // Inside main function
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <filename> <numThreads>\n";
        return 1;
    }

    std::string filename = argv[1];
    int numThreads = std::stoi(argv[2]);
    
    std::ifstream file(filename);
    if (!file) {
        std::cerr << "Error opening file: " << filename << "\n";
        return 1;
    }

    std::string fileContents((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();
    
    // Calculate chunk size for each thread
    size_t chunkSize = fileContents.size() / numThreads;
    std::vector<std::thread> threads;

    
    for (int i = 0; i < numThreads; ++i) {
        size_t start = i * chunkSize;
        size_t end = (i == numThreads - 1) ? fileContents.size() : (start + chunkSize);
    
        // Adjust end to avoid splitting a word
        while (end < fileContents.size() && isalnum(fileContents[end])) {
            end++;
        }
    
        std::string textChunk = fileContents.substr(start, end - start);
        threads.emplace_back(processChunk, textChunk);
    }
    
    for (auto& t : threads) {
        t.join();
    }

    // after joining threads
    std::vector<std::pair<std::string, int>> sortedWords(wordCount.begin(), wordCount.end());
    std::sort(sortedWords.begin(), sortedWords.end(), [](const auto& a, const auto& b) {
        return a.second > b.second;
    });
    
    for (const auto& pair : sortedWords) {
        std::cout << pair.first << " " << pair.second << "\n";
    }


    return 0;
}

